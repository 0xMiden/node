# Checks that run once per day.
#
# These are generally expensive jobs that don't provide enough utility to run on _every_ PR.
name: nightly

on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *" # Everyday at 06:00am UTC

permissions:
  contents: read

jobs:
  # Run tests on the beta channel to provide feedback for Rust team.
  beta-test:
    name: test on beta channel
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6
        with:
          ref: "next"
      - name: Cleanup large tools for build space
        uses: ./.github/actions/cleanup-runner
      - uses: ./.github/actions/install-rocksdb
      - uses: ./.github/actions/install-protobuf-compiler
      - name: Rustup
        run: rustup install beta && rustup default beta
      - uses: taiki-e/install-action@v2
        with:
          tool: nextest@0.9.122
      - name: Run tests
        run: make test

  # Check all feature combinations work individually.
  #
  # This check is too expensive to run on every PR, both in terms of CPU and cache size.
  check-features:
    name: feature combinations
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v6
        with:
          ref: "next"
      - name: Cleanup large tools for build space
        uses: ./.github/actions/cleanup-runner
      - uses: ./.github/actions/install-rocksdb
      - uses: ./.github/actions/install-protobuf-compiler
      - name: Install rust
        run: rustup update --no-self-update
      - name: Install cargo-hack
        uses: taiki-e/install-action@cargo-hack
      - name: Check all feature combinations
        run: make check-features

  workspace-packages:
    name: list packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.package-matrix.outputs.packages }}
    # Deliberately use stable rust instead of the toolchain.toml version.
    # This prevents installing the toolchain version which isn't crucial for this operation.
    env:
      RUSTUP_TOOLCHAIN: stable
    steps:
      - uses: actions/checkout@v6
        with:
          ref: "next"
      - name: Extract workspace packages
        id: package-matrix
        run: |
          PACKAGES=$(cargo metadata --format-version 1 --no-deps \
            | jq -c '
              .workspace_members as $members
              | .packages
              | map(select(.id as $id | $members | index($id)))
              | map(.name)
            ')

          echo "packages=$PACKAGES" >> "$GITHUB_OUTPUT"

  msrv:
    needs: workspace-packages
    runs-on: ubuntu-latest
    strategy:
      matrix:
        package: ${{ fromJson(needs.workspace-packages.outputs.packages) }}
    # Deliberately use stable rust instead of the toolchain.toml version.
    # This is prevents issues where e.g. `cargo-msrv` requires a newer version of rust than the toolchain.toml version.
    env:
      RUSTUP_TOOLCHAIN: stable
    steps:
      - uses: actions/checkout@v6
        with:
          ref: "next"
      - name: Install binstall
        uses: cargo-bins/cargo-binstall@main
      - name: Install cargo-msrv
        run: cargo binstall --no-confirm cargo-msrv
      - name: Get manifest path for package
        id: pkg
        run: |
          MANIFEST_PATH=$(cargo metadata --format-version 1 --no-deps \
            | jq -r '
              .packages[]
              | select(.name == "${{ matrix.package }}")
              | .manifest_path
            ')
          echo "manifest_path=$MANIFEST_PATH" >> "$GITHUB_OUTPUT"
      - name: Show package info
        run: |
          echo "Package: ${{ matrix.package }}"
          echo "Manifest path: ${{ steps.pkg.outputs.manifest_path }}"
          cargo msrv show --manifest-path "${{ steps.pkg.outputs.manifest_path }}"
      - name: Check MSRV
        run: |
          cargo msrv verify --manifest-path "${{ steps.pkg.outputs.manifest_path }}"
